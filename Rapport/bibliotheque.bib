
@inproceedings{pinckney_wasmk_2020,
	location = {New York, {NY}, {USA}},
	title = {Wasm/k: delimited continuations for {WebAssembly}},
	isbn = {978-1-4503-8175-8},
	url = {https://doi.org/10.1145/3426422.3426978},
	doi = {10.1145/3426422.3426978},
	series = {{DLS} 2020},
	shorttitle = {Wasm/k},
	abstract = {{WebAssembly} is designed to be an alternative to {JavaScript} that is a safe, portable, and efficient compilation target for a variety of languages. The performance of high-level languages depends not only on the underlying performance of {WebAssembly}, but also on the quality of the generated {WebAssembly} code. In this paper, we identify several features of high-level languages that current approaches can only compile to {WebAssembly} by generating complex and inefficient code. We argue that these problems could be addressed if {WebAssembly} natively supported first-class continuations. We then present Wasm/k, which extends {WebAssembly} with delimited continuations. Wasm/k introduces no new value types, and thus does not require significant changes to the {WebAssembly} type system (validation). Wasm/k is safe, even in the presence of foreign function calls (e.g., to and from {JavaScript}). Finally, Wasm/k is amenable to efficient implementation: we implement Wasm/k as a local change to Wasmtime, an existing {WebAssembly} {JIT}. We evaluate Wasm/k by implementing C/k, which adds delimited continuations to C/C++. C/k uses Emscripten and its implementation serves as a case study on how to use Wasm/k in a compiler that targets {WebAssembly}. We present several case studies using C/k, and show that on implementing green threads, it can outperform the state-of-the-art approach Asyncify with an 18\% improvement in performance and a 30\% improvement in code size.},
	pages = {16--28},
	booktitle = {Proceedings of the 16th {ACM} {SIGPLAN} International Symposium on Dynamic Languages},
	publisher = {Association for Computing Machinery},
	author = {Pinckney, Donald and Guha, Arjun and Brun, Yuriy},
	urldate = {2023-02-12},
	date = {2020-11-15},
	keywords = {first-class continuations, formal language semantics, virtual machines},
	file = {Version soumise:/home/kira/Zotero/storage/YC2F2W6W/Pinckney et al. - 2020 - Wasmk delimited continuations for WebAssembly.pdf:application/pdf},
}

@online{noauthor_webassembly_nodate,
	title = {{WebAssembly}},
	url = {https://webassembly.org/},
	urldate = {2023-02-12},
	file = {WebAssembly:/home/kira/Zotero/storage/SVF2RV34/webassembly.org.html:text/html},
}

@inreference{noauthor_webassembly_2023,
	title = {{WebAssembly}},
	rights = {Creative Commons Attribution-{ShareAlike} License},
	url = {https://en.wikipedia.org/w/index.php?title=WebAssembly&oldid=1133857733},
	abstract = {{WebAssembly} (sometimes abbreviated Wasm) defines a portable binary-code format and a corresponding text format for executable programs as well as software interfaces for facilitating interactions between such programs and their host environment.The main goal of {WebAssembly} is to enable high-performance applications on web pages, "but it does not make any Web-specific assumptions or provide Web-specific features, so it can be employed in other environments as well." It is an open standard and aims to support any language on any operating system, and in practice all of the most popular languages already have at least some level of support.
Announced in 2015 (2015) and first released in March 2017 (2017-03), {WebAssembly} became a World Wide Web Consortium recommendation on 5 December 2019 and it received the Programming Languages Software Award from {ACM} {SIGPLAN} in 2021. The World Wide Web Consortium (W3C) maintains the standard with contributions from Mozilla, Microsoft, Google, Apple, Fastly, Intel, and Red Hat.},
	booktitle = {Wikipedia},
	urldate = {2023-02-12},
	date = {2023-01-15},
	langid = {english},
	note = {Page Version {ID}: 1133857733},
	file = {Snapshot:/home/kira/Zotero/storage/QGSJMJCQ/WebAssembly.html:text/html},
}

@article{watt_weakening_2019,
	title = {Weakening {WebAssembly}},
	volume = {3},
	url = {https://doi.org/10.1145/3360559},
	doi = {10.1145/3360559},
	abstract = {{WebAssembly} (Wasm) is a safe, portable virtual instruction set that can be hosted in a wide range of environments, such as a Web browser. It is a low-level language whose instructions are intended to compile directly to bare hardware. While the initial version of Wasm focussed on single-threaded computation, a recent proposal extends it with low-level support for multiple threads and atomic instructions for synchronised access to shared memory. To support the correct compilation of concurrent programs, it is necessary to give a suitable specification of its memory model. Wasm's language definition is based on a fully formalised specification that carefully avoids undefined behaviour. We present a substantial extension to this semantics, incorporating a relaxed memory model, along with a few proposed extensions. Wasm's memory model is unique in that its linear address space can be dynamically grown during execution, while all accesses are bounds-checked. This leads to the novel problem of specifying how observations about the size of the memory can propagate between threads. We argue that, considering desirable compilation schemes, we cannot give a sequentially consistent semantics to memory growth. We show that our model provides sequential consistency for data-race-free executions ({SC}-{DRF}). However, because Wasm is to run on the Web, we must also consider interoperability of its model with that of {JavaScript}. We show, by counter-example, that {JavaScript}'s memory model is not {SC}-{DRF}, in contrast to what is claimed in its specification. We propose two axiomatic conditions that should be added to the {JavaScript} model to correct this difference. We also describe a prototype {SMT}-based litmus tool which acts as an oracle for our axiomatic model, visualising its behaviours, including memory resizing.},
	pages = {133:1--133:28},
	issue = {{OOPSLA}},
	journaltitle = {Proceedings of the {ACM} on Programming Languages},
	shortjournal = {Proc. {ACM} Program. Lang.},
	author = {Watt, Conrad and Rossberg, Andreas and Pichon-Pharabod, Jean},
	urldate = {2023-02-20},
	date = {2019-10-10},
	keywords = {assembly languages, just-in-time compilers, programming languages, type systems, Virtual machines},
	file = {Full Text PDF:/home/kira/Zotero/storage/T2K9YIAS/Watt et al. - 2019 - Weakening WebAssembly.pdf:application/pdf},
}

@misc{ullrich_counting_2020,
	title = {Counting Immutable Beans: Reference Counting Optimized for Purely Functional Programming},
	url = {http://arxiv.org/abs/1908.05647},
	doi = {10.48550/arXiv.1908.05647},
	shorttitle = {Counting Immutable Beans},
	abstract = {Most functional languages rely on some garbage collection for automatic memory management. They usually eschew reference counting in favor of a tracing garbage collector, which has less bookkeeping overhead at runtime. On the other hand, having an exact reference count of each value can enable optimizations, such as destructive updates. We explore these optimization opportunities in the context of an eager, purely functional programming language. We propose a new mechanism for efficiently reclaiming memory used by nonshared values, reducing stress on the global memory allocator. We describe an approach for minimizing the number of reference counts updates using borrowed references and a heuristic for automatically inferring borrow annotations. We implemented all these techniques in a new compiler for an eager and purely functional programming language with support for multi-threading. Our preliminary experimental results demonstrate our approach is competitive and often outperforms state-of-the-art compilers.},
	number = {{arXiv}:1908.05647},
	publisher = {{arXiv}},
	author = {Ullrich, Sebastian and de Moura, Leonardo},
	urldate = {2023-03-08},
	date = {2020-03-05},
	eprinttype = {arxiv},
	eprint = {1908.05647 [cs]},
	keywords = {Computer Science - Programming Languages},
	file = {arXiv Fulltext PDF:/home/kira/Zotero/storage/RK8782EQ/Ullrich et de Moura - 2020 - Counting Immutable Beans Reference Counting Optim.pdf:application/pdf;arXiv.org Snapshot:/home/kira/Zotero/storage/QYXW9H7K/1908.html:text/html},
}

@inproceedings{de_macedo_webassembly_2022,
	location = {New York},
	title = {{WebAssembly} versus {JavaScript}: Energy and Runtime Performance},
	isbn = {978-1-66548-286-8},
	url = {https://ieeexplore.ieee.org/document/9830108/},
	doi = {10.1109/ICT4S55073.2022.00014},
	shorttitle = {{WebAssembly} versus {JavaScript}},
	abstract = {The worldwide Web has dramatically evolved in recent years. Web pages are dynamic, expressed by programs written in common programming languages given rise to sophisticated Web applications. Thus, Web browsers are almost operating systems, having to interpret/compile such programs and execute them. Although {JavaScript} is widely used to express dynamic Web pages, it has several shortcomings and performance inefficiencies. To overcome such limitations, major {IT} powerhouses are developing a new portable and size/load efficient language: {WebAssembly}. In this paper, we conduct the first systematic study on the energy and run-time performance of {WebAssembly} and {JavaScript} on the Web. We used micro-benchmarks and also real applications in order to have more realistic results. Preliminary results show that {WebAssembly}, while still in its infancy, is starting to already outperform {JavaScript}, with much more room to grow. A statistical analysis indicates that {WebAssembly} produces significant performance differences compared to {JavaScript}. However, these differences differ between micro-benchmarks and real-world benchmarks. Our results also show that {WebAssembly} improved energy efficiency by 30\%, on average, and showed how different {WebAssembly} behaviour is among three popular Web Browsers: Google Chrome, Microsoft Edge, and Mozilla Firefox. Our findings indicate that {WebAssembly} is faster than {JavaScript} and even more energy-efficient. Additionally, our benchmarking framework is also available to allow further research and replication.},
	pages = {24--34},
	booktitle = {2022 International Conference on Ict for Sustainability (ict4s 2022)},
	publisher = {Ieee},
	author = {De Macedo, Joao and Abreu, Rui and Pereira, Rui and Saraiva, Joao},
	urldate = {2023-03-16},
	date = {2022},
	note = {{WOS}:000859727000003},
	keywords = {Energy Efficiency, Green Software, Runtime, web, Web Browsers, {WebAssembly}},
	file = {Texte intégral:/home/kira/Zotero/storage/XABKEMDD/De Macedo et al. - 2022 - WebAssembly versus JavaScript Energy and Runtime .pdf:application/pdf},
}

@inproceedings{johnson_sfi_2021,
	location = {Reston},
	title = {{SFI} safety for native-compiled Wasm},
	isbn = {978-1-891562-66-2},
	url = {https://www.ndss-symposium.org/wp-content/uploads/ndss2021_5B-3_24078_paper.pdf},
	doi = {10.14722/ndss.2021.24078},
	abstract = {{WebAssembly} (Wasm) is a platform-independent bytecode that offers both good performance and runtime isolation. To implement isolation, the compiler inserts safety checks when it compiles Wasm to native machine code. While this approach is cheap, it also requires trust in the compiler's correctness-trust that the compiler has inserted each necessary check, correctly formed, in each proper place. Unfortunately, subtle bugs in the Wasm compiler can break-and have broken-isolation guarantees. To address this problem, we propose verifying memory isolation of Wasm binaries post-compilation. We implement this approach in {VeriWasm}, a static offline verifier for native x86-64 binaries compiled from Wasm; we prove the verifier's soundness, and find that it can detect bugs with no false positives. Finally, we describe our deployment of {VeriWasm} at Fastly.},
	booktitle = {28th Annual Network and Distributed System Security Symposium (ndss 2021)},
	publisher = {Internet Soc},
	author = {Johnson, Evan and Thien, David and Alhessi, Yousef and Narayan, Shravan and Brown, Fraser and Lerner, Sorin and {McMullen}, Tyler and Savage, Stefan and Stefan, Deian},
	urldate = {2023-03-16},
	date = {2021},
	note = {{WOS}:000680821200063},
	file = {Texte intégral:/home/kira/Zotero/storage/X8LRP7JH/Johnson et al. - 2021 - SFI safety for native-compiled Wasm.pdf:application/pdf},
}

@online{noauthor_wasmer_nodate,
	title = {Wasmer - The Universal {WebAssembly} Runtime},
	url = {https://wasmer.io/},
	abstract = {Wasmer - The Universal {WebAssembly} Runtime},
	urldate = {2023-03-16},
	file = {Snapshot:/home/kira/Zotero/storage/5HBR9DK3/wasmer.io.html:text/html},
}

@online{noauthor_webassembly_2023-1,
	title = {{WebAssembly} {\textbar} {MDN}},
	url = {https://developer.mozilla.org/en-US/docs/WebAssembly},
	abstract = {{WebAssembly} is a new type of code that can be run in modern web browsers — it is a low-level assembly-like language with a compact binary format that runs with near-native performance and provides languages such as C/C++, C\# and Rust with a compilation target so that they can run on the web. It is also designed to run alongside {JavaScript}, allowing both to work together.},
	urldate = {2023-03-16},
	date = {2023-02-23},
	langid = {american},
}

@inproceedings{stievenart_compositional_2020,
	location = {Los Alamitos},
	title = {Compositional Information Flow Analysis for {WebAssembly} Programs},
	isbn = {978-1-72819-248-2},
	url = {https://biblio.vub.ac.be/vubirfiles/75991494/informationflow_copyright.pdf},
	abstract = {{WebAssembly} is a new W3C standard, providing a portable target for compilation for various languages. All major browsers can run {WebAssembly} programs, and its use extends beyond the web: there is interest in compiling cross-platform desktop applications, server applications, {IoT} and embedded applications to {WebAssembly} because of the performance and security guarantees it aims to provide. Indeed, {WebAssembly} has been carefully designed with security in mind. In particular, {WebAssembly} applications are sandboxed from their host environment. However, recent works have brought to light several limitations that expose {WebAssembly} to traditional attack vectors. Visitors of websites using {WebAssembly} have been exposed to malicious code as a result. In this paper, we propose an automated static program analysis to address these security concerns. Our analysis is focused on information flow and is compositional. For every {WebAssembly} function, it first computes a summary that describes in a sound manner where the information from its parameters and the global program state can flow to. These summaries can then be applied during the subsequent analysis of function calls. Through a classical fixed-point formulation, one obtains an approximation of the information flow in the {WebAssembly} program. This results in the first compositional static analysis for {WebAssembly}. On a set of 34 benchmark programs spanning 196kLOC of {WebAssembly}, we compute at least 64\% of the function summaries precisely in less than a minute in total.},
	pages = {13--24},
	booktitle = {2020 20th Ieee International Working Conference on Source Code Analysis and Manipulation (scam 2020)},
	publisher = {Ieee Computer Soc},
	author = {Stievenart, Quentin and De Roover, Coen},
	urldate = {2023-03-16},
	date = {2020},
	note = {{ISSN}: 1942-5430
{WOS}:000647642000002},
	keywords = {web, {WebAssembly}, security, static analysis, Static program analysis},
}

@online{hayes_building_2023,
	title = {Building the component model for Wasm},
	url = {https://www.infoworld.com/article/3689875/building-the-component-model-for-wasm.html},
	abstract = {The {WebAssembly} component model lays the groundwork for a language-agnostic component system, one that allows any Wasm application to use components written in any programming language.},
	titleaddon = {{InfoWorld}},
	author = {Hayes, Bailey},
	urldate = {2023-03-16},
	date = {2023-03-07},
	langid = {english},
	file = {Snapshot:/home/kira/Zotero/storage/WXGPWWDU/building-the-component-model-for-wasm.html:text/html},
}

@inproceedings{haas_bringing_2017,
	location = {New York, {NY}, {USA}},
	title = {Bringing the web up to speed with {WebAssembly}},
	isbn = {978-1-4503-4988-8},
	url = {https://dl.acm.org/doi/10.1145/3062341.3062363},
	doi = {10.1145/3062341.3062363},
	series = {{PLDI} 2017},
	abstract = {The maturation of the Web platform has given rise to sophisticated and demanding Web applications such as interactive 3D visualization, audio and video software, and games. With that, efficiency and security of code on the Web has become more important than ever. Yet {JavaScript} as the only built-in language of the Web is not well-equipped to meet these requirements, especially as a compilation target. Engineers from the four major browser vendors have risen to the challenge and collaboratively designed a portable low-level bytecode called {WebAssembly}. It offers compact representation, efficient validation and compilation, and safe low to no-overhead execution. Rather than committing to a specific programming model, {WebAssembly} is an abstraction over modern hardware, making it language-, hardware-, and platform-independent, with use cases beyond just the Web. {WebAssembly} has been designed with a formal semantics from the start. We describe the motivation, design and formal semantics of {WebAssembly} and provide some preliminary experience with implementations.},
	pages = {185--200},
	booktitle = {Proceedings of the 38th {ACM} {SIGPLAN} Conference on Programming Language Design and Implementation},
	publisher = {Association for Computing Machinery},
	author = {Haas, Andreas and Rossberg, Andreas and Schuff, Derek L. and Titzer, Ben L. and Holman, Michael and Gohman, Dan and Wagner, Luke and Zakai, Alon and Bastien, {JF}},
	urldate = {2023-03-16},
	date = {2017-06-14},
	keywords = {virtual machines, assembly languages, just-in-time compilers, programming languages, type systems},
	file = {Full Text PDF:/home/kira/Zotero/storage/MTJD8IDP/Haas et al. - 2017 - Bringing the web up to speed with WebAssembly.pdf:application/pdf},
}

@online{noauthor_wasmati_nodate,
	title = {Wasmati: An efficient static vulnerability scanner for {WebAssembly} {\textbar} Elsevier Enhanced Reader},
	url = {https://reader.elsevier.com/reader/sd/pii/S0167404822001407?token=1A424725E4364C14A4E8F87B68C9358E37BDF60E9CBD2B3A17FEF50668AE50F6C0051BEEDFB3AEB7E8B00A6EB5D186ED&originRegion=eu-west-1&originCreation=20230316195601},
	shorttitle = {Wasmati},
	urldate = {2023-03-16},
	langid = {english},
	doi = {10.1016/j.cose.2022.102745},
	file = {Full Text PDF:/home/kira/Zotero/storage/3ISGLKHI/Wasmati An efficient static vulnerability scanner.pdf:application/pdf},
}

@incollection{huisman_two_2021,
	location = {Cham},
	title = {Two Mechanisations of {WebAssembly} 1.0},
	volume = {13047},
	isbn = {978-3-030-90869-0 978-3-030-90870-6},
	url = {https://link.springer.com/10.1007/978-3-030-90870-6_4},
	abstract = {{WebAssembly} (Wasm) is a new bytecode language supported by all major Web browsers, designed primarily to be an eﬃcient compilation target for low-level languages such as C/C++ and Rust. It is unusual in that it is oﬃcially speciﬁed through a formal semantics. An initial draft speciﬁcation was published in 2017 [14], with an associated mechanised speciﬁcation in Isabelle/{HOL} published by Watt that found bugs in the original speciﬁcation, ﬁxed before its publication [37].},
	pages = {61--79},
	booktitle = {Formal Methods},
	publisher = {Springer International Publishing},
	author = {Watt, Conrad and Rao, Xiaojia and Pichon-Pharabod, Jean and Bodin, Martin and Gardner, Philippa},
	editor = {Huisman, Marieke and Păsăreanu, Corina and Zhan, Naijun},
	urldate = {2023-03-16},
	date = {2021},
	langid = {english},
	doi = {10.1007/978-3-030-90870-6_4},
	note = {Series Title: Lecture Notes in Computer Science},
	file = {Watt et al. - 2021 - Two Mechanisations of WebAssembly 1.0.pdf:/home/kira/Zotero/storage/EYUYHACX/Watt et al. - 2021 - Two Mechanisations of WebAssembly 1.0.pdf:application/pdf},
}

@inproceedings{menetrey_twine_2021,
	location = {Chania, Greece},
	title = {Twine: An Embedded Trusted Runtime for {WebAssembly}},
	isbn = {978-1-72819-184-3},
	url = {https://ieeexplore.ieee.org/document/9458925/},
	doi = {10.1109/ICDE51399.2021.00025},
	shorttitle = {Twine},
	abstract = {{WebAssembly} is an increasingly popular lightweight binary instruction format, which can be efﬁciently embedded and sandboxed. Languages like C, C++, Rust, Go, and many others can be compiled into {WebAssembly}. This paper describes {TWINE}, a {WebAssembly} trusted runtime designed to execute unmodiﬁed, language-independent applications. We leverage Intel {SGX} to build the runtime environment without dealing with language-speciﬁc, complex {APIs}. While {SGX} hardware provides secure execution within the processor, {TWINE} provides a secure, sandboxed software runtime nested within an {SGX} enclave, featuring a {WebAssembly} system interface ({WASI}) for compatibility with unmodiﬁed {WebAssembly} applications. We evaluate {TWINE} with a large set of general-purpose benchmarks and real-world applications. In particular, we used {TWINE} to implement a secure, trusted version of {SQLite}, a well-known full-ﬂedged embeddable database. We believe that such a trusted database would be a reasonable component to build many larger application services. Our evaluation shows that {SQLite} can be fully executed inside an {SGX} enclave via {WebAssembly} and existing system interface, with similar average performance overheads. We estimate that the performance penalties measured are largely compensated by the additional security guarantees and its full compatibility with standard {WebAssembly}. An indepth analysis of our results indicates that performance can be greatly improved by modifying some of the underlying libraries. We describe and implement one such modiﬁcation in the paper, showing up to 4.1× speedup. {TWINE} is open-source, available at {GitHub} along with instructions to reproduce our experiments.},
	eventtitle = {2021 {IEEE} 37th International Conference on Data Engineering ({ICDE})},
	pages = {205--216},
	booktitle = {2021 {IEEE} 37th International Conference on Data Engineering ({ICDE})},
	publisher = {{IEEE}},
	author = {Menetrey, James and Pasin, Marcelo and Felber, Pascal and Schiavoni, Valerio},
	urldate = {2023-03-16},
	date = {2021-04},
	langid = {english},
	file = {Menetrey et al. - 2021 - Twine An Embedded Trusted Runtime for WebAssembly.pdf:/home/kira/Zotero/storage/5W5CSFAS/Menetrey et al. - 2021 - Twine An Embedded Trusted Runtime for WebAssembly.pdf:application/pdf},
}

@incollection{oliveira_stack-driven_2020,
	location = {Cham},
	title = {Stack-Driven Program Generation of {WebAssembly}},
	volume = {12470},
	isbn = {978-3-030-64436-9 978-3-030-64437-6},
	url = {https://link.springer.com/10.1007/978-3-030-64437-6_11},
	abstract = {{WebAssembly} (Wasm) is a popular portable assembly-like language. Besides browser support in the four most common browsers (Chrome, Firefox, Safari, Edge) a number of standalone Wasm engines are available. With several such independent implementations naturally follows a risk of disagreement between the individual implementations.},
	pages = {209--230},
	booktitle = {Programming Languages and Systems},
	publisher = {Springer International Publishing},
	author = {Perényi, Árpád and Midtgaard, Jan},
	editor = {Oliveira, Bruno C. d. S.},
	urldate = {2023-03-16},
	date = {2020},
	langid = {english},
	doi = {10.1007/978-3-030-64437-6_11},
	note = {Series Title: Lecture Notes in Computer Science},
	file = {Perényi et Midtgaard - 2020 - Stack-Driven Program Generation of WebAssembly.pdf:/home/kira/Zotero/storage/27ZZS6L3/Perényi et Midtgaard - 2020 - Stack-Driven Program Generation of WebAssembly.pdf:application/pdf},
}

@software{noauthor_wabt_2023,
	title = {{WABT}: The {WebAssembly} Binary Toolkit},
	rights = {Apache-2.0},
	url = {https://github.com/WebAssembly/wabt},
	shorttitle = {{WABT}},
	abstract = {The {WebAssembly} Binary Toolkit},
	publisher = {{WebAssembly}},
	urldate = {2023-03-16},
	date = {2023-03-16},
	note = {original-date: 2015-09-14T18:14:23Z},
	keywords = {webassembly},
}

@inproceedings{murphy_use_2020,
	location = {Cham},
	title = {On the Use of Web Assembly in a Serverless Context},
	isbn = {978-3-030-58858-8},
	doi = {10.1007/978-3-030-58858-8_15},
	series = {Lecture Notes in Business Information Processing},
	abstract = {This paper considers how {WASM} can be run in different serverless contexts. A comparison of different serverside {WASM} runtime options is considered, specifically focused on wasmer, wasmtime and lucet. Next, different options for running {WASM} within two serverless platforms – Openwhisk and {AWS} Lambdai – are compared. Initial results show that a solution which uses the built-in node.js {WASM} supports is found to work better than using the dedicated {WASM} runtimes but this has limitations and providing more direct integration with {WASM} runtimes should be explored further.},
	pages = {141--145},
	booktitle = {Agile Processes in Software Engineering and Extreme Programming – Workshops},
	publisher = {Springer International Publishing},
	author = {Murphy, Seán and Persaud, Leonardas and Martini, William and Bosshard, Bill},
	editor = {Paasivaara, Maria and Kruchten, Philippe},
	date = {2020},
	langid = {english},
	keywords = {Runtimes, Serverless, {WASM}, Web Assembly},
	file = {Full Text PDF:/home/kira/Zotero/storage/DFZZABV8/Murphy et al. - 2020 - On the Use of Web Assembly in a Serverless Context.pdf:application/pdf},
}

@online{noauthor_wasmtime_nodate,
	title = {Wasmtime},
	url = {https://wasmtime.dev/},
	urldate = {2023-03-16},
	file = {Wasmtime:/home/kira/Zotero/storage/JJDE48P3/wasmtime.dev.html:text/html},
}

@online{noauthor_nodejs_nodate,
	title = {Node.js Et {WebAssembly}},
	url = {https://nodejs.dev/fr/learn/nodejs-with-webassembly/},
	abstract = {Découvrez pourquoi {WebAssembly} est un outil génial et apprenez à l'utiliser par vous-même.},
	titleaddon = {Node.js Et {WebAssembly}},
	urldate = {2023-03-16},
	langid = {english},
	note = {Section: Node.js},
	file = {Snapshot:/home/kira/Zotero/storage/XC86PPYK/nodejs-with-webassembly.html:text/html},
}
