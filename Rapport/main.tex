\documentclass{rapportECL}
\usepackage{lipsum}
\usepackage{biblatex} %Imports biblatex package
\addbibresource{bibliotheque.bib}

\title{Rapport ECL - Template} %Titre du fichier

\begin{document}

%----------- Informations du rapport ---------

\titre{Un Langage "Pur" pour Web Assembly} %Titre du fichier .pdf
\UE{PSTL} %Nom de la UE

\enseignant{Frédéric \textsc{Peschanski}} %Nom de l'enseignant

\eleves{Lucas \textssc{Fumard} \\
	Lauryn \textsc{Pierre} \\
	Saïd Mohammad \textsc{ZUHAIR} } %Nom des élèves

%----------- Initialisation -------------------

\fairemarges %Afficher les marges
\fairepagedegarde %Créer la page de garde
\tabledematieres %Créer la table de matières

%------------ Corps du rapport ----------------
\section{Introduction}
Le but de notre projet est de concevoir un langage 100 $\%$ fonctionnel et “pur” pour WebAssembly en 
se basant sur cet article\cite{ullrich_counting_2020}(fourni). L'article défini un langage fonctionnel dont la gestion de la mémoire se fait par 
un mécanisme de comptage de références.
WebAssembly\cite{noauthor_webassembly_nodate} ou Wasm définit un format de code binaire portable
et un langage de type assembleur\cite{noauthor_webassembly_2023}. Tous les principaux navigateurs peuvent exécuter des programmes WebAssembly. 
Des langages comme C, C++, Rust, Go et bien d'autres peuvent être compilés en WebAssembly. 

\section{WebAsssembly}

JavaScript est le seul langage de programmation native au Web. 
Pour de nombreuses raisons, JavaScript n’est pas idéal pour être une cible de compilation efficace pour les langages de bas niveau tels que C/C++ et Rust. 
WebAssembly a plusieurs objectifs\cite{haas_bringing_2017}. Être sûre, les programmes WebAssembly sont isolées de leur environnement hôte. 
WebAssembly est conçu pour être lié à aucun runtime ou langages de programmation, de sorte qu'il peut être exécuté sur n'importe quel 
appareil qui le prend en charge et d’avoir le même comportement. 
Ce qui le rend intéressant pour la création d'applications multiplateformes.
Les programmes pouvant être exécutées sur des ordinateurs de bureau, des appareils mobiles, et même des serveurs. 
WebAssembly fonctionne avec les technologies Web existants, par exemple JavaScript, CSS, et HTML.
WebAssembly est un langage bytecode portable de bas niveau pris en charge par les principaux navigateurs Web. 
Les utilisations de WebAssembly ne se limitent pas qu'au Web, il y a aussi un intérêt pour l'Internet des Objets, les serveurs, les systèmes embarqués.
\par WebAssembly a un format texte (.wat) et un format binaire (.wasm). 
WebAssembly peut être exécuté dans différents environnements, tels que les serveurs, les navigateurs web ou les applications. 
Dans les navigateurs web, WebAssembly est exécuté en même temps que le code JavaScript. 
Pour les serveurs, WebAssembly est exécuté en utilisant des runtimes tels que Node.js. 
Plusieurs compilateurs ont été développés pour WebAssembly\cite{noauthor_wabt_2023,noauthor_wasm3_2023,noauthor_wasmer_nodate,noauthor_wasmtime_nodate}. 
Wasmer\cite{noauthor_wasmer_nodate} et wasmtime\cite{noauthor_wasmtime_nodate} sont les plus connues. 
Ils utilisent tous les deux la technique de la compilation à la volée. Wasmtime est développé en collaboration supervisée par la fondation Mozilla. 
Alors que wasmer est développé par une entreprise privée. 
Dans le cadre de notre projet, on utilise wabt\cite{noauthor_wabt_2023} pour compiler et on exécute le compilé à l’aide de Node.js\cite{noauthor_nodejs_nodate}. 
\par Les programmes sont composés d'un ou plusieurs modules. Un module contient la définition des fonctions, variables globales. 
Les définitions peuvent être importées ou exportées.
Ils interagissent avec l’environnement à l’aide d’import et d’export explicites. 
Un module doit être validé avant l’exécution pour s’assurer qu’il est bien typé et sûr d’exécuter. 
WebAssembly possède un système de type statique centré autour de quatre valeurs :  i32, i64, f32 et f64. 
Qui désignent les nombres entiers de 32 bits et 64 bits et les flottants de 32 et 64 bits.  
La spécification officielle de Wasm comprend une sémantique formelle pour le langage, 
avec une déclaration précise de la propriété de solidité des types prévue. 
Elle a d'abord été publiée dans un premier projet en 2017, puis dans la norme officielle, appelée WebAssembly 1.0 (Wasm 1.0), en 2019.
\par La mémoire d’un programme Wasm repose sur le modèle de mémoire linéaire\cite{haas_bringing_2017}. 
La mémoire linéaire est un tampon continu d'octets non signés  que JavaScript et Wasm peuvent lire et modifier de manière synchrone. 
Au cours de l’exécution, l’espace mémoire peut grandir. 

\begin{figure}[ht]
	\centering
	\includegraphics[scale=0.65]{logos/model_memory_wasm.png}	
	\caption{WebAssembly Architecture \cite{noauthor_wasmati_nodate}}
\end{figure}
\FloatBarrier 



\section{Lecture de l'article} \label{section:article}
Le langage fonctionnel décrit dans l'article\cite{ullrich_counting_2020} alloue ses constructeurs dans la pile et manipule des 
adresses vers ces emplacements mémoire alloués. Il est donc primordial d'avoir un système d'allocation et réutilisation de 
mémoire performant afin d'éviter les fuites mémoires et un temps d'exécution faible.

Le système de la gestion de la mémoire par comptage de référence est bien plus vieux que des systèmes par garbage collector, 
mais aussi plus efficaces\cite{ullrich_counting_2020}. Cependant, la gestion de mémoire comptage de références ne fonctionne que si 
il n'est pas possible de créer de cycle de référence. 
C'est pourquoi les garbage collector ne sont plus utilisés de nos jours.

Les auteurs de l'article\cite{ullrich_counting_2020} ont créé un langage fonctionnel dans lequel les cycles de références 
sont impossibles afin d'implémenter un système de gestion de mémoire par comptage de référence et d'obtenir un langage fonctionnel 
dont l'exécution est optimisée. Ils définissent un langage source $\lambda_{pure}$. 
Qui, après une étape de compilation, deviendra $\lambda_{RC}$, notre langage de destination.
$\lambda_{RC}$ est une extension de $\lambda_{pure}$ auquel on a ajouté les instructions de gestion de la mémoire : 
\verb|inc|, \verb|dec|, \verb|reset|, \verb|reuse|.
Notre interpréteur implémentera le langage $\lambda_{pure}$ et notre compilateur, le langage $\lambda_{RC}$.


Les tâches que nous avons identifiées sont les suivantes :

- Analyser le fonctionnement de WASM et étudier son écosystème.

- Programmer un parseur qui puisse lire le langage pur tel que défini dans l'article\cite{ullrich_counting_2020}

- Programmer un interpréteur en Rust du langage selon les sémantiques du langage pur

- Définir quelques tests unitaires couvrant les sémantiques définies dans l'article

- Ajouter la gestion des instructions \verb|inc|, \verb|dec|, \verb|reset|, \verb|reuse|

- Programmer un compilateur du langage agrandi vers WASM

Comme dans l'article, nous partons du principe que le typage a déjà été vérifié et que les \verb|let| inutiles ont été enlevés.

\section{AST}

Concernant la grammaire du langage, nous reprenons celle qui est définie dans la section 3 de l'article et retranscrit dans la Figure ~\ref{fig:grammaire pure} ci-dessous.

\begin{figure}[hbt!]
	\centering
	\includegraphics[scale=0.65]{logos/grammaire.png}
	\caption{Grammaire du langage source $\lambda_{pure}$}
	\label{fig:grammaire pure}
\end{figure}
\FloatBarrier

Nous avons implémenté en Rust l'AST du langage proposé par les auteurs, en en étendant les 
expression (\verb|Expr|) pour ajouter la notion d'entiers à notre interpréteur,
sou la forme \verb|Expr::Num(i32)| en Rust afin de tester concrètement notre interpréteur à partir de
langages lus de fichiers.

\bigskip

Les énumérateurs feuilles dans notre AST sont les variables \verb|Var| et les constantes \verb|Const|,
qui contiennent chacunes une chaîne de charactère décrivant le nom de la fonction pour les constantes et 
le nom de la variable pour les variables. La valeur de la variable peut être récupérée dans le tas
une fois que l'on a l'adresse, obtenue à partir de la pile et de la chaîne de charactère.

\medskip

Une expression peut être un appel de fonction (\verb|FnCall(Const, Vec<Var>)|), un appel de fonction partielle (\verb|PapCall(Var, Var)|),
une fonction partielle (\verb|Pap(Const, Vec<Var>)|), un constructeur (\verb|Ctor(i32, Vec<Var>)|), 
l'obtention d'un champ d'un objet (\verb|Proj(i32, Var)|), ou un entier (\verb|Num(i32)|).

\medskip

Chaque constructeur est défini par un entier différent, détaillé par les constantes globales ci-dessous.

\begin{figure}[H]
\begin{equation*}
CONST\_FALSE = 0
\end{equation*}
\begin{equation*}
CONST\_TRUE = 1
\end{equation*}
\begin{equation*}
CONST\_NIL = 2
\end{equation*}
\begin{equation*}
CONST\_LIST = 3
\end{equation*}
\begin{equation*}
CONST\_NUM = 4
\end{equation*}
\caption{Type des constructeurs dans le langage $\lambda{pure}$}
\label{listing:types_ctor}
\end{figure}
\FloatBarrier 
Ainsi, nous avons défini les booléens \verb|False| et \verb|True| par les entiers \verb|0| et \verb|1| respectivement.

Nous utilisons des identifiants plutôt qu'une énumération où l'on pourrait définir chaque type proprement car 
c'est comme cela que nous allons stocker les types en mémoire en WASM.

Une fois le contructeur créé, nous pouvons accéder aux champs du contructeur avec \verb|Proj|.
Il est à noter que seules les listes ont des champs, car ce sont les seuls constructeur qui prennent
des variables en paramètres pour être créés.

\medskip

Une application partielle \verb|Pap| est un appel de fonction dans lequel il manque des arguments, 
et un appel de fonction partiel \verb|PapCall| est une application partielle désignée par une variable
à laquelle nous ajoutons une autre variable, augmentant le nombre d'arguments de un. 
Une fois qu'il y a assez d'arguments dans le vecteur d'arguments de l'application partielle,
la fonction désignée est exécutée, avec tous les arguments.

\bigskip

En remonttant dans l'AST, nous trouvons les corps de fonction qui peuvent être le retour de fonction d'une variable \verb|Ret(Var)|, 
une affectation de variable \verb|Let(Var, Expr, Box<FnBody>)| ou un match du type d'une variable 
\verb|Case(Var, Vec<FnBody>)|.

L'affectation interprète son expression afin d'injecter la valeur en résultant dans le tas, donc l'adresse est associée
au nom de sa variable, sur la pile. Ainsi, cette variable référencera la valeur de l'expression
dans la suite de la fonction.

\medskip

Pour savoir quel branche du \verb|Case| il faut exécuter, il suffit tout simplement de regarder
l'identifiant du type du constructeur. Ainsi, si l'on veut exécuter du code pour les listes,
il faut d'abord remplir les branches de \verb|False|, \verb|True| et \verb|Nil|.
Il n'est pas nécessaire de remplir la branche pour les entiers si on considère qu'aucun entier
ne sera jamais évalué dans ce \verb|Case|. Le cas échéant, l'interprète lance une erreur et le comportement
du langage compilé en WASM est indéterminé.

\medskip

Le corps de fonction à la racine de la fonction, encapsulant tous les corps suivant, 
est lui-même encapsulé dans la définition d'une fonction \verb|Fn| composée d'une liste (un vecteur en Rust) de variables \verb|Vec<Var>| ainsi que
d'un corps de fonction \verb|FnBody|.

\medskip

Enfin, à la racine de notre AST, nous définissons un \verb|Program| en Rust comme une \verb|IndexMap<Const, Fn>| liant des constantes \verb|Const| à 
des définitions de fonction \verb|Fn|.

\bigskip

\section{Parser/reader}

Notre reader utilise la bibliothèque Chumsky\cite{zesterer_chumsky_nodate}, ainsi, nous ne pouvons pas stoker les noms définis 
variables, ce qui nous empêche de distinguer directement les constantes des variables, car sans historique de définition de variable, 
tous les mots en paramètres de fonction sont lus en tant que \verb|Const|.

C'est pourquoi nous avons besoin de transformer certaines constantes et certains appels de fonctions en variables et applications partielles à l'aide de 
fonction d'explorations définies dans le fichier \verb|transform_var.rs|.
Les variables définies avec un \verb|let| sont donc ainsi représentées par \verb|Var| au lieu de \verb|Const| dans l'AST à interpréter.

C'est aussi avec ce transformateur que l'on transforme les applications en applicaations partielles si il n'y a pas assez d'arguments
pour exécuter la fonction.

Ainsi, nous obtenus un AST bien formé et correct, où une constante est réellement une constante et une application
complète est aussi réellement une application complète.

\section{Interpréteur}

La première étape de notre projet était de créer un interpréteur du langage $\lambda{pure}$, sans instruction de gestion de références.

\subsection{Mémoire}

Afin d'implémenter un interpréteur du langage décrit, il nous a d'abord fallu implémenter les structures permettant d'accéder à la mémoire, 
dont les structures du tas et de la pile (\verb|Heap| et \verb|Ctxt|), comme définies par les auteurs de l'article selon la Figure ~\ref{fig:memory} ci-dessous.

\begin{figure}[hbt!]
	\centering
	\includegraphics[scale=0.65]{logos/figure_strutures_interpreteur.png}
	\caption{Structures de gestion de la mémoire} 
	\label{fig:memory}
\end{figure}
\FloatBarrier 


\verb|Loc| est l'adresse de la case mémoire allouée pour la valeur dans le tas. C'est la valeur de retour de toutes les sémantiques 
du langage, tel que définies dans la figure 1 de l'article\cite{ullrich_counting_2020}.
Contrairement à l'article, nous avons choisi de ne pas retourner un nouveau tas à chaque fois, mais de garder un même tas que 
l'on modifie par effet de bord.

\medskip

\subsubsection{Pile}

La pile est implémentée par un énumérateur \verb|Ctxt| contenant les champs pour le nom de la variable, 
l'emplacement de la variable dans le tas, ainsi que la suite de la pile. 
On agrandi cette pile en l'englobant dans un nouvel énumérateur \verb|Ctxt| contenant les champs 
de la nouvelle variable ainsi que l'ancienne pile. 

Nous ne transmettons pas la pile crée à l'appelant, ainsi la pile est automatiquement dépilée lorsque l'on quitte le 
block d'affectation de variable.

Pour chercher une variable, nous parcourons la pile de l'exterieur vers l'intérieur de façon récursive jusqu'à obtenir la variable 
souhaitée ou arriver à la fin de la pile, dans quel cas l'interpréteur produit une erreur.

Ainsi, nous obtenons une structure de type FILO caractérisant le comportement d'une pile.

\medskip

\subsubsection{Tas}

Nous avons choisi de diverger un peu de l'article\cite{ullrich_counting_2020} en introduisant un tas changé par effet de bord, 
et non passé en sortie de block afin de rendre une seule valeur de retour.

Ce tas \verb|Heap| est une structure contenant le nombre totale d'allocations ainsi qu'une table de hashage d'un entier 
vers un \verb|Value|. Pour la compilation, nous allons réserver la première case pour stocker le nombre d'allocations totales,
ainsi, cette case est définie à 1 dans un tas vide.

Cette structure permet de lier des emplacements et les valeurs et fonctionne avec \verb|Ctxt|. 

Les auteurs de l'artice stockent un couple \verb|(Valeur, entier)|, où l'entier est le nombre de références de l'objet. Nous l'implémentons dans
le compilateur, mais comme l'interpréteur n'adapte que la partie pure du langage, le nombre de références n'est jamais modifié. De ce 
fait, nous avons préféré enlevé la présence de ce nombre dans l'interpréteur pour simplifier la lecture du code.

\medskip

Ainsi, \verb|Ctxt| permet de prendre une référence associée à un nom de variable et \verb|Heap| permet de prendre la valeur associée à cette référence.

\bigskip

\subsection{Interprétation}

Une fois le programme parsé et transformé, nous pouvons interpréter le programme, c'est à dire exécuter une expression dans le 
contexte du programme. Toutes les fonctions de l'interpréteur s'exécutent avec une pile et un tas. Ainsi, nous créons une pile vierge
et un tas vide que nous passons en référence à chaque fonction de l'interpréteur.

Ensuite, il nous suffit d'interpréter les instructions en respectant les règles sémantiques du langage telles que définies par les auteurs, 
selon la Figure ~\ref{fig:semantics} ci-dessous.

\begin{figure}[hbt!]
	\centering
	\includegraphics[scale=0.70]{logos/semantics.png}
	\caption{Sémantiques du langage $\lambda_{pure}$}
	\label{fig:semantics}
\end{figure}
\FloatBarrier 


\bigskip


Il est à noter que, comme indiqué précédemment, nous ne renvoyons pas le nouveau tas à chaque instruction, comme les auteurs, 
mais seulement l'emplacement de l'objet dans la mémoire, car nous avons préféré modifier le tas par effet de bord.

Nous n'avons pas non plus implémenté les instructions \verb|inc|, \verb|dec|, \verb|reset|, et \verb|reuse|, et donc la notion
de références dans cet interpréteur car ces instructions ne font pas partie du langage $\lambda_{pure}$, mais du $\lambda_{RC}$.
Nous les implémentons donc dans le compilateur, qui compile le langage $\lambda_{RC}$ étendu.

Ainsi, hormis le tas et les l'apparition des instructions \verb|inc| et \verb|dec|, nous avons strictement respecté les 
règles sémantiques du langage $\lambda_{pure}$.

\medskip

Ainsi, pour interpréter un \verb|let|, nous interprétons d'abord l'expression associée, qui renvoie un emplacement dans le tas
de la valeur interprétée, et nous lions cet emplacement à la variable du \verb|let| en étendant la pile, qui nous passons dans 
la suite du programme.

\medskip

Pour un \verb|case|, il suffit de récupérer le type de la valeur dans le tas de dont l'emplacement a été lié dans la pile à la variable 
donnée, puis interpréter la suite de l'AST stocké dans un vecteur selon le type du constructeur (voir Figure~\ref{listing:types_ctor}).
Une fois le type de la variable récupéré, il s'agit donc d'un simple accès à un vecteur.

\medskip

Pour un \verb|proj|, nous récupérons la valeur à travers la pile puis le tas, puis, si l'index du champ demandé ne dépasse pas la 
taille du vecteur des champs du constructeur, nous renvoyons l'emplacement stocké.

\medskip

Pour l'interprétation des applications de constantes, il faut d'abord savoir si il s'agit d'une primitive ou d'une fonction 
définie par l'utilisateur, puis nous fixons les arguments aux noms des paramètres de la fonctions puis nous exécutons le corps de la fonction.
Il n'y a pas besoin de vérifier que le nombre d'arguments soit exact, car le transformateur s'est occupé de transformer celles-ci
en définitions d'applications partielles sur des constantes.

\medskip

Enfin, s'il s'agit d'une application partielle, nous vérifions le nombre d'arguments puis nous exécutons une routine similaire,
en interprétant le corps de la fonction demandée avec les arguments fixés si le nombre d'arguments correspond, ou
nous renvoyons une nouvelle application partielle étendue du nouvel argument appliqué si il n'y en a pas assez.

\bigskip

Nous avons par ailleurs défini un certain nombre de primitives arithmétiques et booléennes qui nous permettent d'écrire et 
de tester des programmes dans le langage $\lambda_{pure}$.

\begin{figure}[H]
	\begin{itemize}
		\item Fonctions arithmétiques (\verb|add|, \verb|sub|, \verb|mul|, \verb|div|, \verb|mod|)
		\item Fonctions booléennes sur booléens (\verb|and|, \verb|or|, \verb|not|)
		\item Fonctions booléennes sur nombres (\verb|eq|, \verb|sup|, \verb|inf|, \verb|sup_eq|, \verb|inf_eq|)
	\end{itemize}
	\label{primitives}
	\caption{Liste des primitives implémentées}
\end{figure}

\bigskip

Nous avons testé cet interpréteur en créant plusieurs tests sur les sémantiques, mais aussi quelques programmes simples, 
tels que le calcul de fibonacci.
%, ou le programme \verb|swap| défini à la page 5 de l'article\cite{ullrich_counting_2020}.

\begin{figure}[H]
	\begin{lstlisting}
	fibo n = let m1 = 1; 
		let a = inf_eq n m1; let m2 = 2; case a of
		(let x = sub n m1; let y = sub n m2; 
			let m = fibo x; let n = fibo y;
			let r = add m n; ret r)
		(ret n)
	\end{lstlisting}
	\caption{Implémentation d'un algorithme naïf de calcul de fibonacci}
	\label{listing:fibo_naif}
\end{figure}
\FloatBarrier 

\section{Compilateur}

La dernière étape de notre projet était de créer un compilateur du langage $\lambda{RC}$. Pour cela, il faut insérer les 
instructions \verb|inc|, \verb|dec|, \verb|reset| et \verb|reuse| dans l'AST. Ainsi, la première chose à faire était
d'étendre l'AST et de créer un transformateur du langage $\lambda{pure}$ vers le langage $\lambda{RC}$.

\subsection{AST}


\begin{figure}[hbt!]
	\centering
	\includegraphics[scale=0.40]{logos/grammaire_RC.png}
	\caption{Grammaire du langage $\lambda_{RC}$}
	\label{fig:grammaire RC}
\end{figure}
\FloatBarrier 

\subsection{Insertion des instructions de références} \label{section:insert_inc_dec}


\subsection{Environnement d'exécution}

Notre compilateur génère du code sous le format WAT, le format texte du langage WebAssembly. Ainsi, nous avons besoin
du ompilateur \verb|wat2wasm| pour créer du code WASM compilé.

Pour être exécuté, un module WASM a besoin d'être appelé par un script JavaScript. Ainsi, nous avons créer un fichier 
\verb|runtime.js| qui regroupe toutes les fonctions necéssaires à l'exécution d'un module WASM ainsi que l'interprétation
du résultat obtenu. Nous avons aussi ajouté des fonctions de création de constructeurs de façon à créer et ajouter des objets 
dans la mémoire avant d'appeler une fonction du module WASM.

\subsection{Structure de la mémoire en WASM}

Pour implémenter le langage en WASM, nous avons besoin de deux structures essentielles : le tas et la pile.

\medskip

Pour la pile, nous n'implémentons pas de structure particulière, nous utilisons la pile de WASM lors de l'appel d'une fonction.

\medskip

Afin d'implémenter le tas en WebAssembly, nous utilisons une structure \verb|Memory| qui nous permet de définir une mémoire que 
nous pouvons manipuler de WebAssembly ainsi que de JavaScript.
C'est dans cette mémoire que nous stockons les objets que nous créons
L'accès à cette mémoire nous permettra de réaliser des diagnostics ainsi que des évaluations de l'empreinte mémoire.
Nous avons commencé à définir le schéma du tas du code compilé :
La case mémoire 0 est réservée pour indiquer le prochain espace mémoire libre. Par défault, nous mettons la valeur de cette case à 
l'adresse de la seconde case, soit 4, car la mémoire est alignée sur des entiers naturels de 32 bit ou 4 octets.
Ensuite, chaque constructeur suit le format suivant : \verb|<type> <nb_ref> <args>|. Ainsi, un constructeur \verb|FALSE| référencé 
deux fois est représenté sous la forme "0 2" dans la mémoire. Un entier 10 référencé 3 fois sous la forme "4 3 10".


\subsection{Applications partielles}

Pour les applications partielles, nous avons décider de les stocker dans le tas de la même façon que toutes les autres valeurs.
Il nous faut cependant trouver une alternative au stockage du nom de la fonction en une chaîne de charactères, car WebAssembly
ne supporte pas ce type. Ainsi, nous avons décidé de donner à chaque fonction, primitive ou définie par l'utilisateur, un identifiant
sous forme d'un entier, qui nous servira à choisir quelle fonction appeler lors de l'exécution de l'application partielle.
Il nous faut aussi définir un nouveau nombre définissant le type des applications partielles, étendant les types déjà définis
par à la Figure~\ref{listing:types_ctor}. Bien que nous définissions les applications partielles de la même façon que les constructeurs,
les applications partielles n'en sont pas. 

\medskip

Ainsi, nous définissons ces types selon la figure suivante.


\begin{figure}[H]
	\begin{equation*}
	CONST\_FALSE = 0
	\end{equation*}
	\begin{equation*}
	CONST\_TRUE = 1
	\end{equation*}
	\begin{equation*}
	CONST\_NIL = 2
	\end{equation*}
	\begin{equation*}
	CONST\_LIST = 3
	\end{equation*}
	\begin{equation*}
	CONST\_NUM = 4
	\end{equation*}
	\begin{equation*}
	CONST\_PAP = 5
	\end{equation*}
	\caption{Type des constructeurs dans le langage $\lambda{RC}$ en WASM}
	\label{listing:types_ctor_wasm}
	\end{figure}
	\FloatBarrier 

\medskip

Dans la mémoire, nos applications partielles sont stockés sous la forme 
\verb|<type>| \verb|<nombre| \verb|de références>| \verb|<identifiant| \verb|de la fonction>| \verb|<nombre| \verb|d'arguments| \verb|fixés>| \verb|<arguments>|. 
Par exemple, une application partielle est sous la forme \verb|5 1 7 2 12 13 0| où 5 est le type "application partielle", 
1 est le nombre de références à cette application partielle, 
7 est l'identifiant de la fonction à appeler (dans l'interpréteur, on utilise des \verb|string|), 
2 est le nombre d'arguments fixés et 12 et 13 sont les arguments fixés.
0 est l'emplacement des arguments non fixés que la fonction peut accepter.

\subsection{Schéma mémoire}

Voici donc le schéma de stockage des objets dans la mémoire.


\begin{figure}[H]
	\begin{itemize}
		\item False : 0 <\#refs>
		\item True  : 1 <\#refs>
		\item Nil   : 2 <\#refs>
		\item List  : 3 <\#refs> <@arg1> <@arg2>
		\item Num   : 4 <\#refs> <entier>
		\item Pap   : 5 <\#refs> <id fonction> <\#arguments fixés> <@arg1> <@arg2> ...
	\end{itemize}
	\caption{Schéma mémoire}
	\label{listing:memory_wasm}
\end{figure}

\subsection{Compilation des instructions en WAT}

Nous avons choisi d'adopter un style impératif dans la compilation des instructions de WebAssembly. En effet, ce style nous permet 
de regrouper des instructions récurentes en fonctions, ce qui simplifie la lecture du code du compilateur. Cependant, nous utilisons
quelques fois dans la compilation et dans ce rapport un style semblable à du Lisp, les instructions enballées dans des parenthèses.
Ces deux styles sont strictement valables en WebAssembly.

\subsubsection{Formation des objets dans la mémoire}

Pour créer les objets dans la mémoire, nous avons écrit quelques fonctions en WebAssembly.
Ces fonctions, \verb|__make_num|, \verb|__make_no_arg|, \verb|__make_list| et \verb|__make_pap|, modifie la mémoire
pour y former un objet du type demandé. Puis, ces fonctions modifie l'emplacement 0 de la mémoire, pour y écrire le
prochain emplacement libre. 

Chaque fonction implémentent dans la mémoire un des quatre stockages différents définis dans le schéma de la 
mémoire à la figure~\ref{listing:memory_wasm}.

\bigskip

La fonction la plus simple est \verb|__make_no_arg|. C'est avec cette fonction que nous créons des objets sans paramètres,
soit les booléens \verb|False| et \verb|True| et le mot de fin de liste \verb|Nil|. Pour utiliser cette fonction,
nous chargeons d'abord l'identifiant du type demandé, soit \verb|CONST_FALSE| (0), \verb|CONST_TRUE| (1) ou \verb|CONST_NIL| (2),
puis \verb|__make_no_arg| met cet identifiant à l'adresse désignée par la case 0, initialise le nombre de références à 1 dans la
case d'adresse suivante, et incrémente de 8 la valeur de la case 0 pour l'aligner à la prochaine case vide. 
Enfin, l'adresse de l'objet créé est renvoyée.

Ainsi, l'objet est créé et la prochaine adresse disponible est définie comme étant celle de la case suivant l'objet.

\bigskip

Les fonctions \verb|__make_num| et \verb|__make_list| ont un fonctionnement similaire, mais prennent en paramètres non pas le 
l'objet mais les arguments de l'objet à créer, soit l'entier à créer pour \verb|__make_num|, et les adresses des objets composant la tête et la 
queue de la liste pour \verb|__make_list|. La valeur de la case 0 est incrémentée de 12 et de 16 respectivement.

\bigskip

Enfin, la fonction \verb|__make_pap| prend seulement l'identifiant de la fonction appliquée. Elle écrit ensuite le type de l'objet, 
soit \verb|CONST_PAP| (5), le nombre de références (1), l'identifiant de la fonction donné en paramètre et le nombre d'arguments 
fixés, initialisé à 0. La fonction libère ensuite la place nécessaire à l'écriture de l'ensemble des arguments fixés.
Elle incrémente donc la valeur de la case 0 de $16 + N * 4 $ où $N$ est le nombre d'arguments que la fonction de l'identifiant attend.

Ainsi, pour obtenir ce nombre d'arguments par fonction, il nous faut définir une fonction interne, \verb|$__nb_args| qui est 
compilée de sorte à associer chaque identifiant de fonction au nombre de paramètres, que nous récoltons au préalable à la 
compilation, avec l'utilisation des instructions \verb|block| et \verb|br_table|.

L'utilisation de ces deux instructions est la suivante.

\begin{figure}[H]
	\begin{lstlisting}[escapeinside={(*@}{@*)}]
  (block $b1
    (block $b2
      local.get $x (*@ \label{ex_br_table_x}@*)
      (br_table $b2 $b1)
    ) (*@ \label{ex_br_table_b2}@*)
    i32.const 0 (*@ \label{ex_br_table_0}@*)
    return
  ) (*@ \label{ex_br_table_b1}@*)
  i32.const 1 (*@ \label{ex_br_table_1}@*)
  return
	\end{lstlisting}
	\caption{Example d'utilisation de block et br\_table en WebAssembly}
	\label{listing:example_block_br_table}
\end{figure}

Des \verb|block|s avec un label \verb|$l| peuvent être définis. L'on peut sortir du \verb|block| en enbranchant au label du 
\verb|block| avec une instruction du type \verb|br $l|.

La \verb|br_table| est une table permettant d'effectuer un enbranchement selon la valeur en haut de la pile.
La valeur 0 enbranchera sur la branche d'index 0, la valeur 1 enbranchera sur la branche d'index 1, etc\dots
Il est à noter qu'une valeur supérieure à la taille de la table enbranchera sur la dernière branche de la table.

Ainsi, en associant les deux, et avec la figure~\ref{listing:example_block_br_table} comme exemple, si la valeur x (ligne~\ref{ex_br_table_x})
est \verb|0|, la table enbranchera à la fin du block \verb|$b2| pour exécuter la suite du programme (ligne~\ref{ex_br_table_b2}) et 
retourner la valeur \verb|0|. Si la valeur de x (ligne~\ref{ex_br_table_x}) est \verb|1| ou supérieure, la table enbranchera à la fin du 
block \verb|$b1| pour exécuter la suite du programme (ligne~\ref{ex_br_table_b1}) et retourner la valeur \verb|1|.

\subsubsection{Compilation des fonctions}

Pour compiler une fonction, il faut d'abord récolter le nom de toutes les variables utilisées afin de les 
déclarer et on y ajoute une variale utile à certains scenarios de compilation, \verb|$__intern_var|.
Ensuite, nous changeons le nom interne de la fonction pour ajouter "fun\_" devant pour éviter les 
redéfinitions de fonctions internes.
Nous ajoutons également "var\_" à toutes les variables définies pour éviter de les méler à la variable interne \verb|__intern_var|.
Il suffit enfin d'écrire la signature de la fonction, en n'oubliant pas d'exporter au nom original.

Puis, on compile le corps de la fonction, et on ajoute derrière une parenthèse fermante pour fermer la fonction.

Ainsi, la structure de la fonction \verb|fibo| de la figure~\ref*{listing:fibo_naif} est la suivante :
\begin{figure}[H]
	\begin{lstlisting}[escapeinside={(*@}{@*)}]
  (func $fun_fibo (export "fibo") (param $n i32) (result i32)
    (local $__intern_var i32)
    (local $var_m1 i32)
    (local $var_m2 i32)
    (local $var_a i32)
    (local $var_r i32)
    (local $var_y i32)
    (local $var_x i32)
    (local $var_m i32)
    ;; corps de la fonction
  )
	\end{lstlisting}
	\caption{Compilation de la signature de la fonction fibo}
	\label{listing:signature_fibo}
\end{figure}

\subsubsection{Let}

Le \verb|let| est très simple à compiler, en effet, il faut compiler l'expression en premier pour mettre la valeur de retour 
dans la variable, et compiler le reste de la fonction. Pour une variable \verb|x| définie par l'utilisateur, le code est donc le suivant

\begin{figure}[H]
	\begin{lstlisting}[escapeinside={(*@}{@*)}]
  ;; expression
  local.set var_x
  ;; corps de fonction suivant
	\end{lstlisting}
	\caption{Compilation d'un let}
	\label{listing:compile_let}
\end{figure}


\subsubsection{Case}

Pour compiler les \verb|case|, nous avons besoin d'une structure nous permettant d'exécuter une branche du code suivant la valeur du 
type de la variable donnée. Ainsi, nous utilisons la combinaison de \verb|block| et \verb|br_table| aussi utilisée pour l'exécution
d'une application partielle, comme montré sur la figure~\ref*{listing:example_block_br_table}.

Le code d'une instruction \verb|case| à deux embranchements sur la variable \verb|x| définie par l'utilisateur 
se compile ainsi de la manière suivante


\begin{figure}[H]
	\begin{lstlisting}[escapeinside={(*@}{@*)}]
  (block $__case0
    (block $__case1
      local.get $var_x
      i32.load
      (br_table $_case1 $_case0)
	)
    ;; suite si type False
  )
  ;; suite si type True
	\end{lstlisting}
	\caption{Compilation d'un case}
	\label{listing:compile_case}
\end{figure}

\subsubsection{Proj}

On ne peut exécuter un proj que sur un objet de type \verb|CONST_LIST|, car c'est le seul constructeur qui contient des champs qui
pointent vers d'autres objets.

Pour compiler un $proj_i$, il suffit de renvoyer le champ désigné par i, soit ajouter $(i + 1)*4$ à l'adresse de la variable, car
d'après notre schéma de la mémoire, le seul constructeur possédant des champs est la liste, dont les champs commencent deux cases 
après le début de l'objet.
Il ne faut pas oublier que nous commençons l'indexation des champs à 1, c'est à dire que $proj_1$ donne le premier champ, 
$proj_2$ le deuxième, etc\dots

Ainsi, pour une variable \verb|x| de type liste définie par l'utilisateur, la compilation de $proj_1$ est la suivante.
\begin{figure}[H]
	\begin{lstlisting}[escapeinside={(*@}{@*)}]
  local.get $var_x
  ;; calcul de l'offset en ajoutant la case des references et sur alignement des entier 32 bits
  ;; sur liste : 3 4 123 456, proj1 => 123 (offset de 8) et proj2 => 456 (offset de 12)
  i32.const 8 ;; (i + 1) * 4
  i32.add     ;; calcul de l'adresse a recuperer
  i32.load    ;; chargement du champ (adresse d'un objet)
\end{lstlisting}
\caption{Compilation d'un $proj_1$}
\label{listing:compile_proj}
\end{figure}

\subsubsection{Application complète}

Pour l'application complète d'une fonction définie par l'utilisateur, il faut charger tous les arguments donnés puis appeler 
l'équivalent de la fonction en compilé. Ainsi, l'application des variables \verb|x| et \verb|y| définiées par l'utilisateur sur 
la fonction \verb|f| définie par l'utilisateur se compile selon la figure~\ref*{listing:compile_app_comp_const}.

\begin{figure}[H]
	\begin{lstlisting}[escapeinside={(*@}{@*)}]
  local.get $var_x
  local.get $var_y
  call $fun_f
	\end{lstlisting}
	\caption{Compilation d'une application complète}
	\label{listing:compile_app_comp_const}
\end{figure}

Si la fonction est une primitive, nous appliquons les arguments sur la définition de la primitive en WebAssembly.
Voici par exemple dans la figure~\ref*{listing:compile_add} la compilation de la primitive \verb|add| appliquée aux variables 
\verb|x| et \verb|y| définies par l'utilisateur.

\begin{figure}[H]
	\begin{lstlisting}[escapeinside={(*@}{@*)}]
  ;; decallage de deux entiers, la place de la valeur du nombre
  (i32.load (i32.add (local.get $var_x) (i32.const 8)))
  (i32.load (i32.add (local.get $var_y) (i32.const 8)))
  i32.add
  call $__make_num
  
  (call $__dec (local.get $var_x))
  (call $__dec (local.get $var_y))
	\end{lstlisting}
	\caption{Compilation d'une application sur une primitive}
	\label{listing:compile_add}
\end{figure}

Il ne faut pas oublier de décrémenter les références des objet, car leur des \verb|inc| ont été ajoutés, comme spécifié dans la 
section~\ref{call $__dec} lors de l'application sur \verb|add| dans l'expression \verb|add x y|.

\subsubsection{Application partielle}

L'application d'une variable sur une application partielle est délicat. En effet, nous avons choisi d'implémenter les applications 
partielles en stockant toutes les variables appliquées dans la mémoire. Cependant, cela signifie que nous devons copier l'application
partielle avant d'y fixer la nouvelle variable et incrémenter le nombre d'arguments. Nous appelons donc la fonction 
\verb|__copy_pap| qui crée une nouvelle application partielle du même type et copie les arguments un à un.

Puis, si il y a assez de variables fixées d'après \verb|__nb_args|, nous appelons la fonction \verb|__exec_pap|, qui charge les 
variables une à une sur la pile d'exécution de WebAssembly avec une \verb|loop| puis nous appelons la fonction ou nous compilons 
la primitive selon ce sur quoi l'application partielle est basée. 

De la même manière qu'avec la compilation de \verb|case|, nous savons quelle branche appeler grâce à la 
combinaison des instructions \verb|block| et \verb|br_table| .Une fois le code compilé, cette fonction est assez longue, 
car elle contient toutes les primitives définies ainsi que tous les appels des fonctions définies par l'utilisateur.

\subsubsection{Inc et dec}

La compilation d'un \verb|inc| est très simple. En effet, nous ajoutons \verb|1| aux nombre de références de l'objet. 
Ainsi, pour une variable \verb|v| définie par l'utilisateur, le code compilé est le suivant.

\begin{figure}[H]
	\begin{lstlisting}[escapeinside={(*@}{@*)}]
  ;; chargement de l'adresse pour le stockage
  local.get $var_x

  ;; chargement des references
  (i32.add (local.get $var_x) (i32.const 4)) 
  i32.load
   
  ;; calcul des nouvelles references
  i32.const 1
  i32.add

  ;; stockage
  call $__set_ref

  ;; corps de fonction suivant
	\end{lstlisting}
	\caption{Compilation d'un inc}
	\label{listing:compile_inc}
\end{figure}

Avec la fonction \verb|__set_ref|

\begin{figure}[H]
	\begin{lstlisting}[escapeinside={(*@}{@*)}]
  (func $__set_ref (param $adr i32) (param $ref i32)
    ;; mise a jour des refs
    local.get $adr ;; @x
    i32.const 4    ;; @x 4
    i32.add        ;; @refs
    local.get $ref ;; @refs #refs
    i32.store      ;;
  )
	\end{lstlisting}
	\caption{Fonction \_\_set\_ref}
	\label{listing:set_ref}
\end{figure}

Le \verb|dec| est un peu plus compliqué, car il ne suffit pas seulement de décrémenter le nombre de références, il faut aussi 
appliquer un \verb|dec| sur les arguments des \verb|ctor| et \verb|pap| lorsque ceux-ci se retrouvent à 0.
Ainsi, nous définissons une fonction \verb|$__dec|, qui décrémente l'objet et les arguments de l'objet si besoin.

La fonction \verb|__dec| décrémente donc les références de l'objet de façon similaire à \verb|inc|, en utilisant \verb|i32.sub| 
au lieu de \verb|i32.add|, puis si ce nombre de références est nul, teste le type de l'objet. Si ce type est celui de 
\verb|CONST_LIST|, on charge le premier champ de l'objet, pour y appliquer la fonction \verb|$__dec| et de même
sur le deuxième champ. Si le type est ceui de \verb|CONST_PAP|, on utilise une boucle (\verb|loop $nom_boucle| en WebAssembly) pour
charger et chacun des objets du \verb|pap| et y appliquer la fonction \verb|$__dec|.

\subsubsection{Reset et reuse}

La fonction \verb|__reset| décrémente le nombre de références de la variable donnée et renvoie \verb|0| si la variable est 
effectivement détruite ou l'adresse de la variable si elle est encore en vie. Voici le code WebAssembly de cette fonction.

\begin{figure}[H]
	\begin{lstlisting}[escapeinside={(*@}{@*)}]
  (func $__reset (param $var_var i32) (result i32)
    (call $__dec (local.get $var_var))
    (i32.add (local.get $var_var) (i32.const 4))
    i32.load
    i32.eqz
    if
      i32.const 0
      return
    end
    local.get $var_var
  )
	\end{lstlisting}
	\caption{La fonction reset}
	\label{listing:compile_reset}
\end{figure}

Il suffit ensuite de charger la variable concernée et d'appeler cette fonction \verb|__reset|.

\medskip

L'instruction \verb|reset| est toujours suivie d'une instruction \verb|reuse|. Celle ci teste si l'adresse de la variable donnée, 
soit le résultat de l'instruction \verb|reset|, nul puis si il y a assez de place dans l'ancienne variable. Si le résultat de ces
tests est \verb|1|, on peut copier les arguments donnés après \verb|reuse| dans l'emplacement mémoire de l'ancienne variable.

Sinon, on doit créer un nouvel objet selon le \verb|ctor| donné.

\section{Comparaisons}

En testant notre interpréteur et notre compilateur sur une implémentation de la fonction de fibonacci 
(voir Figure~\ref{listing:fibo_naif}), l'on s'apperçoit que le code compilé est à beaucoup plus rapide que le code interprété,
mais surtout qu'il alloue moins d'espace mémoire pour s'exécuter.

TODO : Tableau de Comparaisons

\section{Améliorations possibles}

Comme précisé à la fin de la section~\ref{section:article}, nous avons implémenté un compilateur en partant du principe que le 
typage est bon et que les verb|let| inutiles ont été enlevés. Le langage implémenté n'est donc pas typé statiquement.

De plus, nous avons implémenté les applications partielles de la façon la plus simple à laquelle nous avons pensé. 
Cette implémentation n'est pas optimale car nous créons une nouvelle application partielle avant de l'exécuter et de la détruire.

Nous aurions pu utiliser un unique objet global pour des constructeurs sans arguments tels que $False$, $True$ ou $Nil$. 
Nous avons en effet choisi de créer des objets à chaque fois pour avoir plus d'éléments sur lesquels agir. Dans une 
version plus complète du compilateur, il serait plus intelligent de rendre ces constructeurs sans arguments uniques. L'on 
pourrait par ailleur introduire une meilleure gestion de la mémoire semblable à un \verb|malloc| en C.

De plus, nous n'avons pas non plus implémenté la récursion terminale en WebAssembly. Cependant, l'optimisation des \verb|dec| et \verb|inc| 
sur une récursion terminale dans la section~\ref{section:insert_inc_dec} est tout de même utile.

Enfin, nous n'avons pas réussi à bien implémenter les références pour les applications partielles et dans les \verb|case|. En effet, nous 
obtenons plus d'objets en vie que voulus.

\section{Conclusion}

\printbibliography
\end{document}