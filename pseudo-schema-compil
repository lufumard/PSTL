fichier (fonctions : Vec<Program>)

js:
const memory = new WebAssembly.Memory({
  initial: 10,
  maximum: 100,
});

WebAssembly.instantiateStreaming(fetch("memory.wasm"), {
  js: { mem: memory },
}).then((obj) => {
  const sum = obj.instance.exports.accumulate(0, 10);
  console.log(sum);
});

---------------------
out <- (module
out <-     (memory (import "js" "mem") 1)
compile_program(fonctions[i])*
out <- )


compile_program (cste : Const, fun:Fn)
---------------------
nom = string_of_const(cste)
out <- (func ${nom} (export "{nom}") 
compile_fonction(fun)
out <- )



compile_fonction (nom : Const,  params :Vec<Var>, body : FnBody)
---------------------
for param in params {
out <- (param $params[i] i32 )
}
out <- (result i32)
;; les lignes au dessus sont en une ligne avec la signature de la fonction 
;; sous la forme (func $ajout (export "ajout") (param $a i32) (param $b i32) (result i32)
let vars = catch_vars(body)
for v in vars {
	compile_init_var(v)
}
compile_fnbody(body)


compile_init_var (var : Var)
---------------------
let s = string_of_var(var)
out <- (local ${s} i32)


compile_let (var:Var, expr: Expr, fnbody:FnBody)
---------------------
compile_expr(expr)
let v = string_of_var(var)
out <- local.set ${v}
compile_fnbody(fnbody)


compile_return (var : Var)
---------------------
let s = string_of_var(var)
out <- local.get ${s}
out <- return


compile_inc (var:Var, fnbody:FnBody)
---------------------
TODO
compile_fnbody(fnbody)


compile_dec (var:Var, fnbody:FnBody)
---------------------
TODO
compile_fnbody(fnbody)


compile_var (var:Var)
---------------------
let s = string_of_var(var)
out <- local.get ${s}
out <- i32.load


compile_value(n: i32)
---------------------
out <- i32.const {n}
make_num()


compile_ctor (i: int, params : Vec<Loc>)
---------------------


compile_get_num (var:Var)
---------------------
let s = string_of_var(var)
out <- local.get ${s}
out <- i32.const 8 ;;dÃ©callage de deux entiers, la place de la valeur du nombre
out <- i32.add
out <- i32.load

compile_get_bool (var:Var)
---------------------
let s = string_of_var(var)
out <- local.get ${s}
out <- i32.load ;; types : 0=FALSE, 1=TRUE, 2=NIL, ... donc la valeur du booleen est son type

compile_add (vars:Vec!<Var>)
---------------------
compile_get_num(vars[0])
compile_get_num(vars[1])
out <- i32.add
compile_make_num()
;; valeur en haut de la pile : l'adresse de l'objet

compile_sub (vars:Vec!<Var>)
---------------------
compile_get_num(vars[0])
compile_get_num(vars[1])
out <- i32.sub
compile_make_num()
;; valeur en haut de la pile : l'adresse de l'objet
...

compile_and (vars:Vec!<Var>)
---------------------
compile_get_bool(vars[0]);
out <- (if (then
compile_get_bool(vars[1])
out <- (if (then
compile_make_true()
out <- ) (else
compile_make_false()
out <- ))) (else
compile_make_false()
out <- ))
;; valeur en haut de la pile : l'adresse de l'objet

compile_or (vars:Vec!<Var>)
---------------------
compile_get_bool(vars[0])
out <- (if (then
compile_make_true()
out <- ) (else
compile_get_bool(vars[1])
out <- (if (then
compile_make_true()
out <- ) (else
compile_make_false()
out <- ))))
;; valeur en haut de la pile : l'adresse de l'objet

compile_not (var:Var)
---------------------
compile_get_bool(var)
out <- (if (then
compile_make_false()
out <- ) (else
compile_make_true()
out <- ))
;; valeur en haut de la pile : l'adresse de l'objet